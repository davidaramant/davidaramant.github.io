---
layout: post
title:  "CSV For You and Me"
---
This is intended to be a quick guide to the bare minimum you need to know about the humble CSV format.  Unfortunately there is more confusion about this format than there should be...

Comma-Separated Values files are an extremely useful tool for easily dealing with columnar data.  Maybe you need to quickly export some data into a format you can view as a spreadsheet.  Maybe you already have a spreadsheet but you don't feel like whittling away your fleeting hours of existence looking up arcane Excel commands to do some gnarly transformation.  CSV to the rescue! 

All you have to do is join a bunch of junk with commas and you're down right?  **BOOM DONE SHIP IT LOL**

If you are 100% certain that your columns will never, ever, ever contain a comma or a newline, sure, you're done.  That doesn't happen very often, *especially* when dealing with hand-entered text.  Hand-fixing a mangled CSV file generated by a naive algorithm like this is a great motivator for workplace violence.  Don't be *That Guy* that creates CSV files like this.

#Writing CSV Rows The Correct Wayâ„¢
Thankfully, this is fairly trivial:

{% highlight c# %}
static string CreateCsvRow(params string[] cols)
{
    return String.Join(",", cols.Select(
        col => String.Format("\"{0}\"", col.Replace("\"", "\"\""))));
}
{% endhighlight %}

I'm sure you can port this to whatever other heathen language you are using without much trouble.  

The main problem with CSV is that it really isn't much of a standard at all - if you look around you'll find lots of *slightly* different implementations.  If you have to interface with Crusty Legacy Software 95 you'll probably have to figure out its exact quirks, but for the rest of us (who only really care about whether Excel can open it) the following rules are good enough:

- Fields that have a newline, double-quoute, and/or commas should be quoted
- A double-quote in a field should be escaped by turning it into two double-quotes

Note that the first rule is not a commandment (virtually nothing with CSV sadly is) - Excel will actually spit out CSV files with a mix of quoted and unquoted columns depending on whether the contents require it.  However, it's perfectly happy reading files where every column is quoted, which is way easier for us. There are more rules you probably *should* follow (like keeping the number of columns that same across all rows).  You can check out all that stuff on the [wiki page](http://en.wikipedia.org/wiki/Comma-separated_values#Toward_standardization "wiki page").

#Reading CSV Rows
Unfortunately this is an order of magnitude harder than writing - we can't just split on commas because they might be part of the column contents.  The meaning of a character changes depending on the context.  You might even say it depends on the *state* we are in...

Fortunately, it's not a very complicated state machine:

{% highlight c# %}
private enum RowState
{
    ColumnStart,
    UnescapedColumn,
    EscapedColumn,
    QuoteInEscapedColumn,
}

static IEnumerable<string> ParseCsvRow(string line)
{
    var state = RowState.ColumnStart;

    var currentColumn = new StringBuilder();

    foreach (var c in line)
    {
        switch (state)
        {
            case RowState.ColumnStart:
                if (c == '"')
                {
                    state = RowState.EscapedColumn;
                }
                else if (c == ',')
                {
                    yield return currentColumn.ToString();
                    currentColumn.Clear();
                }
                else
                {
                    state = RowState.UnescapedColumn;
                    currentColumn.Append(c);
                }
                break;

            case RowState.UnescapedColumn:
                if (c == '"')
                {
                    throw new ArgumentException(
                        "Cannot have quote in unescaped column");
                }
                else if (c == ',')
                {
                    yield return currentColumn.ToString();
                    currentColumn.Clear();
                    state = RowState.ColumnStart;
                }
                else
                {
                    currentColumn.Append(c);
                }
                break;

            case RowState.EscapedColumn:
                if (c == '"')
                {
                    state = RowState.QuoteInEscapedColumn;
                }
                else
                {
                    currentColumn.Append(c);
                }
                break;

            case RowState.QuoteInEscapedColumn:
                if (c == '"')
                {
                    currentColumn.Append(c);
                    state = RowState.EscapedColumn;
                }
                else if (c == ',')
                {
                    yield return currentColumn.ToString();
                    currentColumn.Clear();
                    state = RowState.ColumnStart;
                }
                else
                {
                    throw new ArgumentException("Invalid escaped column");
                }
                break;
        }
    }

    if (currentColumn.Length > 0)
    {
        yield return currentColumn.ToString();
    }
}
{% endhighlight %}        

Now, this probably won't handle every horrid malformed CSV file you can dig out of the bowels of a 1994 file server backup, but it can happily handle Excel output which is all that matters 99% of the time.

#Takeaway

The main thing I wanted to get across with this post is that CSV *is not just strings joined with commas*.  If you actually need to read/write CSV in production code it's probably better to dig up some library that actually handles more of the absurd corner cases, but the above snippets will work fine for quick-n-dirty throwaway programs.
